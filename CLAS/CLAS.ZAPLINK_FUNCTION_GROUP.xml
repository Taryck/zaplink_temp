<?xml version="1.0" encoding="utf-16"?>
<ZL_OBJECT CHECKSUM="1FB3B95CF72F444B51648C737321AC59" CODE_SIGNATURE="75D6DF3BF064DD7EE2080E4B084F347D" CONNECTOR="39AC0A4B07A5A05AE1000000AC120173" NAME="ZAPLINK_FUNCTION_GROUP" TYPE="CLAS" VERSION="1.01">
 <DEPENDENCIES>
  <ITEM TYPE="CLAS" NAME="ZAPLINK_CONNECTOR_"/>
  <ITEM TYPE="CLAS" NAME="ZAPLINK_FUGR_DATA"/>
 </DEPENDENCIES>
 <DIRECTORY DEVCLASS="ZAPLINK-CONNECTORS-MAIN" MASTERLANG="E"/>
 <RAW>
  <A0_MAINDATA VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" CLSCCINCL="X" FIXPT="X" UNICODE="X" MSG_ID="ZAPLINK_FUGR">
   <INHERITANCE REFCLSNAME="ZAPLINK_CONNECTOR_" STATE="1"/>
   <TEXTS>
    <ITEM LANG="E" TEXT="Conneector for Function Group">U1&amp;FUNCTIONALITY&amp;
ASIs a connector for :
AS- FUGR : Function Group
U1&amp;RELATIONS&amp;
ASIs part of ZAP Link Framework as Official Connector.
ASRequire Official connector for Program types (PROG).
U1&amp;EXAMPLE&amp;
AS
U1&amp;HINTS&amp;
AS
U1&amp;FURTHER_SOURCES_OF_INF&amp;
AShttps://code.google.com/p/zaplink/wiki/Connector
U1Memories
ASThis application is dedicated to the memories of :
B2My father : Lamri BENSIALI (1940-2004) without whom I never started
  programming
B2My uncle : Jacky BEDU (1934-2009) who died during the completion of this
  application</ITEM>
   </TEXTS>
  </A0_MAINDATA>
  <ATTRIBUTS>
   <ITEM CMPNAME="BALLOG_SUBOBJECT" EXPOSURE="2" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;CNX_FUNCTION_GROUP&apos;" TYPTYPE="1" TYPE="BALSUBOBJ">
    <TEXTS>
     <ITEM LANG="E" TEXT="Application Log: Subobject"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="C_MAINPROG_PREFIX" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;SAPL&apos;" TYPTYPE="1" TYPE="TRDIR-NAME">
    <TEXTS>
     <ITEM LANG="E" TEXT="Function group Main program prefix"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="PREV_FUNC" STATE="1" TYPTYPE="4">
    BEGIN OF prev_func,
     name  TYPE  td_function_name,
     data  TYPE  ts_fmd_func,
   END OF prev_func
`
    <TEXTS>
     <ITEM LANG="E" TEXT="Previous function"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="SUPPORTEDKINDS" EXPOSURE="1" STATE="1" ATTDECLTYP="1" TYPTYPE="4">BEGIN OF supportedkinds,
      group             TYPE td_transport_kind,
      function          TYPE td_transport_kind,
    END OF supportedkinds
`</ITEM>
   <ITEM CMPNAME="SUPPORTEDTYPES" EXPOSURE="1" STATE="1" ATTDECLTYP="2" TYPTYPE="4">
    BEGIN OF supportedtypes,
      group             TYPE td_comptype VALUE &apos;FUGR&apos;,      &quot;#EC NOTEXT
      function          TYPE td_comptype VALUE &apos;FUNC&apos;,      &quot;#EC NOTEXT
    END OF supportedtypes
`
    <TEXTS>
     <ITEM LANG="E" TEXT="Connector supported types"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="_UUID" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;F1838F4B202C2806E1000000AC120173&apos;" TYPTYPE="1" TYPE="TD_CONNUUID">
    <TEXTS>
     <ITEM LANG="E" TEXT="UUID for connector Program"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="_VER" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;1.0&apos;" TYPTYPE="1" TYPE="TD_CONNVER">
    <TEXTS>
     <ITEM LANG="E" TEXT="Connector Version"/>
    </TEXTS>
   </ITEM>
  </ATTRIBUTS>
  <DEFERRED>
   <CLASSES>
    <ITEM TYPEGROUP="ZAPLINK_FUGR_DATA" TPUTYPE="1" EXPLICIT="X"/>
   </CLASSES>
  </DEFERRED>
  <FRIENDS>
   <ITEM REFCLSNAME="ZAPLINK_FUGR_DATA" STATE="1"/>
   <ITEM REFCLSNAME="ZAPLINK_FUNC_DATA" STATE="1"/>
   <ITEM REFCLSNAME="ZAPLINK_FUNC_RAW" STATE="1"/>
  </FRIENDS>
  <LOCAL>
   <TYPES>`
*&quot;* USE THIS SOURCE FILE FOR ANY TYPE DECLARATIONS (CLASS
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</TYPES>
   <IMPLEMENTATIONS>`
*&quot;* LOCAL CLASS IMPLEMENTATION FOR PUBLIC CLASS
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</IMPLEMENTATIONS>
   <MACROS>`
*&quot;* USE THIS SOURCE FILE FOR ANY MACRO DEFINITIONS YOU NEED
*&quot;* in the implementation part of the class

INCLUDE zaplink_macros.</MACROS>
  </LOCAL>
  <METHODS>
   <ITEM CMPNAME="CALC_FUNCTION_SIGNATURE" EXPOSURE="1" STATE="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Determine Source code Signature of a function"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="FUNCTION" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TS_FMD_FUNC">
      <TEXTS>
       <ITEM LANG="E" TEXT="Function Group Name"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="ZAPLINK_DATATYPES~TD_CHECKSUM">
      <TEXTS>
       <ITEM LANG="E" TEXT="MD5 Hash"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  DATA d_src      TYPE string.
  DATA d_lcount   TYPE i.
  DATA t_code     TYPE tt_abaprawsource.
  FIELD-SYMBOLS: &lt;s&gt; LIKE LINE OF function-source.

  CHECK function-source IS NOT INITIAL.   t_code = function-source.
  READ TABLE t_code ASSIGNING &lt;s&gt; INDEX 1.
  IF &lt;s&gt; CP &apos;FUNCTION *.&apos;.    DELETE t_code INDEX 1.   ENDIF.
  d_lcount = LINES( t_code ).
  READ TABLE t_code ASSIGNING &lt;s&gt; INDEX d_lcount.
  IF &lt;s&gt; CP &apos;ENDFUNCTION*.&apos;.    DELETE t_code INDEX d_lcount.   ENDIF.

* Calcul MD5
  zaplink_tools=&gt;pretty_printer( CHANGING table = t_code ).
  zaplink_tools=&gt;condense_abap_source( CHANGING table = t_code ).
  d_src = zaplink_tools=&gt;table_2_string( t_code ).
  d_src = zaplink_tools=&gt;clean_abap_string( d_src ).
  result = zaplink_tools=&gt;calculate_md5_hash( d_src ).</SOURCE>
   </ITEM>
   <ITEM CMPNAME="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" MTDTYPE="2" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="CLASS_CONSTRUCTOR"/>
    </TEXTS>
    <SOURCE>`
  supportedkinds-group =  zaplink_connectors=&gt;get_typekind( supportedtypes-group ).
  supportedkinds-function =  zaplink_connectors=&gt;get_typekind( supportedtypes-function ).</SOURCE>
   </ITEM>
   <ITEM CMPNAME="CONSTRUCTOR" EXPOSURE="2" STATE="1" MTDTYPE="2">
    <TEXTS>
     <ITEM LANG="E" TEXT="CONSTRUCTOR"/>
    </TEXTS>
    <SOURCE>`
  DATA type LIKE LINE OF supported_types.

  CALL METHOD super-&gt;constructor.
  mac_create_log application_log ballog_subobject space.
  type-type = supportedtypes-group.    INSERT type INTO TABLE supported_types.
  type-type = supportedtypes-function. INSERT type INTO TABLE supported_types.

  uuid = _uuid.
  version = _ver.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="DEL_FUNCTION" EXPOSURE="1" STATE="1" MTDNEWEXC="X">
    <TEXTS>
     <ITEM LANG="E" TEXT="Delete function from SAP System is required"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="FUNC" CMPTYPE="1" TYPTYPE="1" TYPE="TS_FMD_FUNC"/>
    </PARAMETERS>
    <EXCEPTIONS>
     <ITEM SCONAME="ZCX_ZL_CONNECTOR" LANGU="E"/>
    </EXCEPTIONS>
    <SOURCE>`
  DATA d_pname     TYPE tfdir-pname.
  DATA d_group     TYPE rs38l-area.
  DATA d_msg       TYPE string.
  DATA t_params    TYPE STANDARD TABLE OF spar WITH DEFAULT KEY.
  DATA s_param     LIKE LINE OF t_params.
  DATA d_answer    TYPE c.

  TRY.

* FROM  FUNCTION &apos;RPY_FUNCTIONMODULE_READ&apos;
    SELECT SINGLE pname INTO d_pname FROM tfdir WHERE funcname = func-header-name.
    IF sy-subrc &lt;&gt; 0.   EXIT.   ENDIF.

    CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
      EXPORTING
        program                            = d_pname
*          SUPPRESS_SELECT                    = &apos;X&apos;
*          COMPLETE_AREA                      = &apos; &apos;
      IMPORTING
*          NAMESPACE                          =
*          FUNCTION_NOT_EXISTS                =
        group                              = d_group
*          FUNCNAME                           =
*          INCLUDE_NUMBER                     =
*          NO_FUNCTION_INCLUDE                =
*          NO_FUNCTION_MODULE                 =
*               SUFFIX                             =
*               RESERVED_NAME                      =
*               TOO_MANY_DELIMITERS                =
*               RESERVED_FOR_EXITS                 =
*               HIDDEN_NAME                        =
*              CHANGING
*                INCLUDE                            = d_pname
      EXCEPTIONS
        include_not_exists                 = 1
        group_not_exists                   = 2
        no_selections                      = 3
        no_function_include                = 4
        no_function_pool                   = 5
        delimiter_wrong_position           = 6
        no_customer_function_group         = 7
        no_customer_function_include       = 8
        reserved_name_customer             = 9
        namespace_too_long                 = 10
        area_length_error                  = 11
        OTHERS                             = 12.
    IF sy-subrc &lt;&gt; 0.   EXIT.   ENDIF.

    IF d_group &lt;&gt; func-header-str_area.    &quot; No problem on overwrite
      IF sy-batch = abap_true.   &quot;only delete in forground
        EXIT.
      ENDIF.

* The function &amp;1 already exist (&amp;2), do you confirm deletion ?
      MESSAGE i000 WITH d_pname d_group INTO d_msg.
      REFRESH t_params.
      s_param-param = &apos;FUNCTION&apos;.   s_param-value = func-header-name.         APPEND s_param TO t_params.
      s_param-param = &apos;GROUP&apos;.      s_param-value = d_group.                  APPEND s_param TO t_params.
      s_param-param = &apos;CURRENT_G&apos;.  s_param-value = func-header-str_area.     APPEND s_param TO t_params.
      CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
        EXPORTING
          titlebar              = &apos;Confirm module function deletion&apos;(d00)
          diagnose_object       = &apos;ZAPLINK_FUNCTION_GROUP-CONF&apos;
          text_question         = d_msg
          text_button_1         = &apos;Yes&apos;(yes)
          icon_button_1         = &apos;ICON_DELETE&apos;
          text_button_2         = &apos;No&apos;(no_)
          icon_button_2         = &apos;ICON_SKIP&apos;
          default_button        = &apos;3&apos;
          display_cancel_button = &apos;X&apos;
          userdefined_f1_help   = &apos;ZAPLINK_FUNCTION_GROUP-CONFH&apos;
          start_column          = 10
          start_row             = 4
          popup_type            = &apos;ICON_MESSAGE_WARNING&apos;
          iv_quickinfo_button_1 = &apos;Function is deleted. Function group will be created with this function.&apos;(hye)
          iv_quickinfo_button_2 = &apos;Function is not deleted and process to next existing function. Function group will be created without this function.&apos;(hno)
        IMPORTING
          answer                = d_answer
        TABLES
          parameter             = t_params
        EXCEPTIONS
          text_not_found        = 1
          OTHERS                = 2.
      IF sy-subrc &lt;&gt; 0.
        mac_add_mf_and_raise &apos;POPUP_TO_CONFIRM&apos; sy-subrc.
      ELSEIF d_answer = &apos;N&apos; OR d_answer = &apos;2&apos;.
        EXIT.
      ELSEIF d_answer = &apos;A&apos;.    &quot; abend
        ROLLBACK WORK.
        mac_add_mf_and_raise &apos;RS_FUNCTION_DELETE&apos; 1.
      ENDIF.
    ENDIF.

    CALL FUNCTION &apos;RS_FUNCTION_DELETE&apos;
      EXPORTING
        funcname                 = func-header-name
        suppress_popups          = abap_true
*               SUPPRESS_CHECKS          = &apos; &apos;
*               SUPPRESS_DELE_ENHA       = &apos; &apos;
*               TRREQUEST                =
      EXCEPTIONS
        cancelled                = 1
        function_released        = 2
        OTHERS                   = 3.
    IF sy-subrc &lt;&gt; 0.
      mac_add_mf_and_raise &apos;RS_FUNCTION_DELETE&apos; sy-subrc.
    ENDIF.
    DELETE FROM tftit WHERE funcname = func-header-name.
    DELETE FROM funct WHERE funcname = func-header-name.

    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="GET_ALL_INCLUDES" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="In subtitution to MF &apos;RS_GET_ALL_INCLUDES&apos;"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_FUNCTIONGROUP_NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="Function group, to which the function module belongs"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULTS" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TT_INCLUDES"/>
     <ITEM SCONAME="WITH_CODE" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PAROPTIONL="X">
      <TEXTS>
       <ITEM LANG="E" TEXT="Not only form include but all include with ABAP Code"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  DATA: _result           LIKE LINE OF results.
  DATA d_include          TYPE rs38l-include.
  DATA d_is_hidden        TYPE abap_bool.
  DATA d_is_extern        TYPE abap_bool.
  DATA d_not_funct        TYPE abap_bool.
  DATA d_suffix           TYPE rs38l-suffix.
* Code from FM &apos;RS_GET_ALL_INCLUDES&apos;
  DATA: program           TYPE trdir-name.
  DATA: _fugr_name        TYPE rs38l-area.
  DATA: _is_reserved_name TYPE c.
  DATA: includes          TYPE STANDARD TABLE OF rseuinc.
  FIELD-SYMBOLS:
    &lt;wa&gt; LIKE LINE OF includes.

  program = get_mainprogram( name ).
* Code from FM &apos;RS_GET_ALL_INCLUDES&apos;
  SELECT * FROM d010inc
           APPENDING CORRESPONDING FIELDS OF TABLE includes
*           appending table includes
           WHERE master = program.
  CALL FUNCTION &apos;RS_WORKING_AREA_ACTIVE_CHECK&apos;
    EXCEPTIONS
      nok = 1.
  IF sy-subrc = 0.
    SELECT * FROM rseuinc
             APPENDING CORRESPONDING FIELDS OF TABLE includes
*             appending table includes
             WHERE master = program.
  ENDIF.
  SORT includes BY include.
  DELETE ADJACENT DUPLICATES FROM includes COMPARING include.
  LOOP AT includes ASSIGNING &lt;wa&gt;.
* change from code from FM &apos;RS_GET_ALL_INCLUDES&apos;
*    CALL FUNCTION &apos;RS_PROGNAME_SPLIT&apos;
    d_include = &lt;wa&gt;-include.
    CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
*     EXPORTING
*       PROGRAM                            =
*       SUPPRESS_SELECT                    = &apos;X&apos;
*       COMPLETE_AREA                      = &apos; &apos;
      IMPORTING
*       NAMESPACE                          =
*       FUNCTION_NOT_EXISTS                =
        group                              = _fugr_name
*       FUNCNAME                           =
*       INCLUDE_NUMBER                     =
        no_function_include                = d_is_extern
        no_function_module                 = d_not_funct
        suffix                             = d_suffix
        reserved_name                      = _is_reserved_name
*       TOO_MANY_DELIMITERS                =
*       RESERVED_FOR_EXITS                 =
        hidden_name                        = d_is_hidden
      CHANGING
        include                            = d_include
      EXCEPTIONS
        include_not_exists                 = 1
        group_not_exists                   = 2
        no_selections                      = 3
        no_function_include                = 4
        no_function_pool                   = 5
        delimiter_wrong_position           = 6
        no_customer_function_group         = 7
        no_customer_function_include       = 8
        reserved_name_customer             = 9
        namespace_too_long                 = 10
        area_length_error                  = 11
        OTHERS                             = 12.
    IF sy-subrc = 0 AND _fugr_name = name AND d_is_extern = abap_false AND
      ( with_code = abap_true OR
              ( d_not_funct = abap_true AND d_is_hidden = abap_false AND
                        ( d_suffix = &apos;TOP&apos; OR _is_reserved_name = abap_false ) ) ) .
      _result-name = &lt;wa&gt;-include.
      _result-source = get_prog_rawsource( _result-name ).
      APPEND _result TO results.
    ENDIF.
  ENDLOOP.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="GET_FUNCTION_SIGNATURE" EXPOSURE="2" STATE="1" MTDNEWEXC="X">
    <TEXTS>
     <ITEM LANG="E" TEXT="Get Source code Signature of a function"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_FUNCTION_NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="Function Group Name"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="ZAPLINK_DATATYPES~TD_CHECKSUM">
      <TEXTS>
       <ITEM LANG="E" TEXT="MD5 Hash"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <EXCEPTIONS>
     <ITEM SCONAME="ZCX_ZL_CONNECTOR" LANGU="E"/>
    </EXCEPTIONS>
    <SOURCE>`
  DATA d_src      TYPE string.
  DATA s_fm_func  TYPE ts_fmd_func.
*  DATA d_lcount   TYPE i.
*  FIELD-SYMBOLS: &lt;s&gt; LIKE LINE OF s_fm_func-source.

  s_fm_func = read_function( name ).
  result = calc_function_signature( s_fm_func ).</SOURCE>
   </ITEM>
   <ITEM CMPNAME="GET_GROUP_SIGNATURE" EXPOSURE="2" STATE="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Get Source code Signature of a function group"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="GROUP_NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_FUNCTIONGROUP_NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="Function Group Name"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="ZAPLINK_DATATYPES~TD_CHECKSUM">
      <TEXTS>
       <ITEM LANG="E" TEXT="MD5 Hash"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  DATA t_includes  TYPE tt_includes.
  DATA t_code      TYPE tt_abaprawsource.
*  DATA t_code_tmp  TYPE tt_abaprawsource.
  DATA d_src       TYPE string.
  DATA d_mainprog  TYPE td_progname.
*  DATA t_functions TYPE tt_rs38l_incl.
  FIELD-SYMBOLS:
    &lt;i&gt; LIKE LINE OF t_includes.
*    &lt;f&gt; LIKE LINE OF t_functions.

* Main Prog
  d_mainprog = get_mainprogram( group_name ).
  t_code = get_prog_rawsource( d_mainprog ).

** Functions
*  CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
*    EXPORTING
*      function_pool           = group_name
*    TABLES
*      functab                 = t_functions
*    EXCEPTIONS
*      function_pool_not_found = 1
*      OTHERS                  = 2.
*  IF sy-subrc &lt;&gt; 0.
*    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*  ENDIF.
*  LOOP AT t_functions ASSIGNING &lt;f&gt;.  t_code_tmp = get_prog_rawsource( &lt;f&gt;-include ).     APPEND LINES OF t_code_tmp TO t_code.   ENDLOOP.

* Includes
  t_includes = get_all_includes( name = group_name
                            with_code = abap_true  ).
  LOOP AT t_includes ASSIGNING &lt;i&gt;.   APPEND LINES OF &lt;i&gt;-source TO t_code.   ENDLOOP.

* Calcul MD5
  zaplink_tools=&gt;pretty_printer( CHANGING table = t_code ).
  zaplink_tools=&gt;condense_abap_source( CHANGING table = t_code ).
  d_src = zaplink_tools=&gt;table_2_string( t_code ).
  d_src = zaplink_tools=&gt;clean_abap_string( d_src ).
  result = zaplink_tools=&gt;calculate_md5_hash( d_src ).</SOURCE>
   </ITEM>
   <ITEM CMPNAME="GET_MAINPROGRAM" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Get main program from Area"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="RS38L-AREA">
      <TEXTS>
       <ITEM LANG="E" TEXT="Function group, to which the function module belongs"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TRDIR-NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="ABAP Program Name"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  DATA s_rs38l TYPE rs38l.
* From LSFUNCTION_BUILDERI01 : module okcode_105 input.
  CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
    EXPORTING
      complete_area = name
    IMPORTING
      namespace     = s_rs38l-namespace
      group         = s_rs38l-str_area
    EXCEPTIONS
      OTHERS        = 6.
  CONCATENATE s_rs38l-namespace c_mainprog_prefix s_rs38l-str_area INTO result.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="READ_FUNCTION" EXPOSURE="1" STATE="1" MTDNEWEXC="X">
    <TEXTS>
     <ITEM LANG="E" TEXT="Read function from SAP System"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_FUNCTION_NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="Name of Function Module"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TS_FMD_FUNC"/>
    </PARAMETERS>
    <EXCEPTIONS>
     <ITEM SCONAME="ZCX_ZL_CONNECTOR" LANGU="E"/>
    </EXCEPTIONS>
    <SOURCE>`
*  STATICS prev_func_name  TYPE  td_function_name.
*  STATICS prev_func_data  TYPE  ts_fmd_func.
  DATA o_data     TYPE to_group.
  DATA s_fmd_fugr TYPE ts_fmd_fugr.
  DATA d_name     TYPE rs38l-name.
  DATA type       TYPE td_comptype.
  DATA d_mainprog TYPE td_progname.
  DATA d_soft_comp TYPE tdevc-dlvunit.
*  DATA t_functions TYPE tt_rs38l_incl.
  DATA s_func LIKE LINE OF s_fmd_fugr-functions.
  DATA t_doc TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
  DATA t_src TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
  data t_src_new type RSFB_SOURCE.    &quot; Issue 98
  DATA t_tmp_doc TYPE tt_docs.
  DATA d_doc TYPE doku_obj.
  DATA s_doc_param TYPE zaplink_fugr_data=&gt;ts_doc_param.
*  FIELD-SYMBOLS:
*    &lt;f&gt; LIKE LINE OF t_functions.

  IF prev_func-name = name.   result = prev_func-data.    RETURN.   ENDIF.    &quot; Use Cache
  TRY.
    result-header-name = s_doc_param-func =  name.
*          s_func-source = get_prog_rawsource( &lt;f&gt;-include ).
    s_doc_param-param = &apos;*&apos;.    d_doc = s_doc_param.
    result-docs = zaplink_documentation=&gt;get( ids = zaplink_fugr_data=&gt;r_doc_ids-function
                                           object =  d_doc ).
*    CALL FUNCTION &apos;RPY_FUNCTIONMODULE_READ&apos;    &quot; Issue 98 : Source might be wider than 72 Chars
    CALL FUNCTION &apos;RPY_FUNCTIONMODULE_READ_NEW&apos;
      EXPORTING
        functionname             = result-header-name
      IMPORTING
        global_flag              = result-header-global
        remote_call              = result-header-remote
        update_task              = result-header-utask
*        SHORT_TEXT               =
        function_pool            = result-header-str_area
      TABLES
        import_parameter         = result-import_p
        changing_parameter       = result-changing_p
        export_parameter         = result-export_p
        tables_parameter         = result-tables
        exception_list           = result-exceptions
        documentation            = t_doc
        SOURCE                   = t_src
      CHANGING
        NEW_SOURCE               = t_src_new
      EXCEPTIONS
        error_message            = 1
        function_not_found       = 2
        invalid_name             = 3
        OTHERS                   = 4.
    IF sy-subrc &lt;&gt; 0.
      mac_add_mf_and_raise &apos;RPY_FUNCTIONMODULE_READ_NEW&apos; sy-subrc.
    ENDIF.
    If not t_src_new is INITIAL.    result-source = t_src_new.    else.   result-source = t_src.    endif.
    SELECT * INTO TABLE result-texts FROM tftit WHERE funcname = result-header-name.
    SELECT * INTO TABLE result-param_texts FROM funct WHERE funcname = result-header-name.

    prev_func-data = result.    prev_func-name = name.

    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="WRITE_FUNCTION" EXPOSURE="1" STATE="1" MTDNEWEXC="X">
    <TEXTS>
     <ITEM LANG="E" TEXT="Write function to SAP System"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="FUNC" CMPTYPE="1" TYPTYPE="1" TYPE="TS_FMD_FUNC"/>
    </PARAMETERS>
    <EXCEPTIONS>
     <ITEM SCONAME="ZCX_ZL_CONNECTOR" LANGU="E"/>
    </EXCEPTIONS>
    <SOURCE>`
  DATA t_doc       TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
  DATA t_src       TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
*  DATA t_src_new   TYPE rsfb_source.                       &quot; Issue 122
  DATA fm_include  TYPE rs38l-include.                      &quot; Issue 122

  TRY.
*    t_src_new = func-source.
    CALL FUNCTION &apos;RPY_FUNCTIONMODULE_INSERT&apos;
      EXPORTING
        funcname                      = func-header-name
        function_pool                 = func-header-str_area
        interface_global              = func-header-global
        remote_call                   = func-header-remote
        short_text                    = space
        suppress_corr_check           = abap_false
        update_task                   = func-header-utask
*        CORRNUM                       = &apos; &apos;
*        NAMESPACE                     = &apos; &apos;
*        new_source                    = t_src_new                    &quot; Issue 122
      IMPORTING
        function_include              = fm_include                    &quot; Issue 122
      TABLES
        import_parameter              = func-import_p
        export_parameter              = func-export_p
        tables_parameter              = func-tables
        changing_parameter            = func-changing_p
        exception_list                = func-exceptions
        parameter_docu                = t_doc
        SOURCE                        = t_src
      EXCEPTIONS
        double_task                   = 1
        error_message                 = 2
        function_already_exists       = 3
        invalid_function_pool         = 4
        invalid_name                  = 5
        too_many_functions            = 6
        no_modify_permission          = 7
        no_show_permission            = 8
        enqueue_system_failure        = 9
        canceled_in_corr              = 10
        OTHERS                        = 11.
    IF sy-subrc &lt;&gt; 0.
      ROLLBACK WORK.
      mac_add_mf_and_raise &apos;RPY_FUNCTIONMODULE_INSERT&apos; sy-subrc.
    ENDIF.
    set_prog_rawsource( program = fm_include                        &quot; Issue 122
                            raw = func-source ).
    MODIFY tftit FROM TABLE func-texts.
    MODIFY funct FROM TABLE func-param_texts.

    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="WRITE_INCLUDE" EXPOSURE="1" STATE="1" MTDNEWEXC="X">
    <TEXTS>
     <ITEM LANG="E" TEXT="Write include to SAP System"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="AREA" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TLIBG-AREA">
      <TEXTS>
       <ITEM LANG="E" TEXT="Function group, to which the function module belongs"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="INCLUDE" CMPTYPE="1" TYPTYPE="1" TYPE="TS_INCLUDE">
      <TEXTS>
       <ITEM LANG="E" TEXT="Include Name"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="MAINPROGRAM" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TRDIR-NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="ABAP Program Name"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="SOURCE" CMPTYPE="1" PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_ABAPRAWSOURCE">
      <TEXTS>
       <ITEM LANG="E" TEXT="MainProgram source"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <EXCEPTIONS>
     <ITEM SCONAME="ZCX_ZL_CONNECTOR" LANGU="E"/>
    </EXCEPTIONS>
    <SOURCE>`
  DATA _oname   TYPE e071-obj_name.
  DATA _rep     TYPE progdir.
  DATA _fugr    TYPE rs38l-area.
  DATA _sufix   TYPE rs38l-suffix.
  DATA f_noinc  TYPE abap_bool.
  DATA _include TYPE rs38l-include.

  _rep-name = _oname = _include = include-name.
  CALL FUNCTION &apos;FUNCTION_INCLUDE_SPLIT&apos;
*   EXPORTING
*     PROGRAM                            =
*     SUPPRESS_SELECT                    = &apos;X&apos;
*     COMPLETE_AREA                      = &apos; &apos;
    IMPORTING
*     NAMESPACE                          =
*     FUNCTION_NOT_EXISTS                =
      group                              = _fugr
*     FUNCNAME                           =
*     INCLUDE_NUMBER                     =
      no_function_include                = f_noinc
*     NO_FUNCTION_MODULE                 =
      suffix                             = _sufix
*     RESERVED_NAME                      =
*     TOO_MANY_DELIMITERS                =
*     RESERVED_FOR_EXITS                 =
*     HIDDEN_NAME                        =
    CHANGING
      include                            = _include
    EXCEPTIONS
      include_not_exists                 = 1
      group_not_exists                   = 2
      no_selections                      = 3
      no_function_include                = 4
      no_function_pool                   = 5
      delimiter_wrong_position           = 6
      no_customer_function_group         = 7
      no_customer_function_include       = 8
      reserved_name_customer             = 9
      namespace_too_long                 = 10
      area_length_error                  = 11
      OTHERS                             = 12.
  IF sy-subrc &lt;&gt; 0.
    mac_add_mf_and_raise &apos;FUNCTION_INCLUDE_SPLIT&apos; sy-subrc.
  ENDIF.
  IF _sufix &lt;&gt; &apos;TOP&apos; OR _fugr &lt;&gt; area OR NOT f_noinc IS INITIAL.
    CALL FUNCTION &apos;RS_CREATE_NEW_INCLUDE&apos;
      EXPORTING
        master                   = mainprogram
        include_name             = _rep-name
        new_include              = abap_true
        insert_include_statement = abap_true
      TABLES
        master_source            = source
      EXCEPTIONS
        program_enqueued         = 1
        OTHERS                   = 2.
    IF sy-subrc &lt;&gt; 0.
      mac_add_mf_and_raise &apos;RS_CREATE_NEW_INCLUDE&apos; sy-subrc.
    ENDIF.
  ENDIF.

  CALL FUNCTION &apos;RS_INSERT_INTO_WORKING_AREA&apos;
    EXPORTING
      object                  = &apos;REPS&apos;
      obj_name                = _oname
*      DELETED_FLAG            = &apos; &apos;
*    IMPORTING
*      OBJECT_INSERTED         =
    EXCEPTIONS
      wrong_object_name       = 1
      OTHERS                  = 2.
  IF sy-subrc &lt;&gt; 0.
    mac_add_mf_and_raise &apos;RS_INSERT_INTO_WORKING_AREA&apos; sy-subrc.
  ENDIF.

* Issue 137 Should not get REPT (no text with includes)
*  CALL FUNCTION &apos;RS_INSERT_INTO_WORKING_AREA&apos;
*    EXPORTING
*      object                  = &apos;REPT&apos;
*      obj_name                = _oname
**      DELETED_FLAG            = &apos; &apos;
**    IMPORTING
**      OBJECT_INSERTED         =
*    EXCEPTIONS
*      wrong_object_name       = 1
*      OTHERS                  = 2.
*  IF sy-subrc &lt;&gt; 0.
*    mac_add_mf_and_raise &apos;RS_INSERT_INTO_WORKING_AREA&apos; sy-subrc.
*  ENDIF.

  _rep-subc = &apos;I&apos;.
  _rep-varcl = abap_true.   &quot; Case sensitive
  _rep-appl = &apos;S&apos;.    &quot; System
  _rep-state = &apos;I&apos;.   MODIFY progdir FROM _rep.
* MODIFY reposrc FROM _rep. &quot;The databae view &quot;REPOSRC&quot; is write-protected, so it cannot be changed.
  _rep-state = &apos;A&apos;.   MODIFY progdir FROM _rep.

  set_prog_rawsource( program = include-name
                          raw = include-source ).</SOURCE>
   </ITEM>
  </METHODS>
  <REDEFINITIONS>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CNX_EXT_CLEANER~ANONYMIZE">
    <SOURCE>`
  DATA o_group    TYPE to_group.
  DATA o_function TYPE to_function.

  CHECK object IS BOUND.

  CASE object-&gt;type.
    WHEN supportedtypes-group.
      o_group ?= object-&gt;raw.
      o_group-&gt;anonymize( ).
    WHEN supportedtypes-function.
      o_function ?= object-&gt;raw.
      o_function-&gt;anonymize( ).
    WHEN OTHERS.
       mac_raise_type_not_supported me-&gt;class_name object-&gt;type.
  ENDCASE.

  TRY.
      super-&gt;zaplink_cnx_ext_cleaner~anonymize( object ).
    CATCH ZCX_ZL_CONNECTOR INTO o_mycx.
      RAISE EXCEPTION o_mycx.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CNX_EXT_CLEANER~UNANONYMIZE">
    <SOURCE>`
*  DATA o_prog TYPE to_program.
*
*  TRY.
*      super-&gt;zaplink_cnx_ext_cleaner~unanonymize( object ).
*    CATCH ZCX_ZL_CONNECTOR INTO o_mycx.
*      RAISE EXCEPTION o_mycx.
*  ENDTRY.
*
*  o_prog ?= object-&gt;raw.
*  o_prog-&gt;A0_MAINDATA-CNAM = sy-uname.
**    o_prog-&gt;A0_MAINDATA-CDAT,
**    o_prog-&gt;A0_MAINDATA-UNAM,
**    o_prog-&gt;A0_MAINDATA-UDAT,
**    o_prog-&gt;A0_MAINDATA-SDATE,
**    o_prog-&gt;A0_MAINDATA-STIME,
**    o_prog-&gt;A0_MAINDATA-IDATE,
**    o_prog-&gt;A0_MAINDATA-ITIME.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CNX_EXT_CODE_SIGNATURE~GET_SIGNATURE">
    <SOURCE>`
  DATA d_group TYPE td_functiongroup_name.
  DATA d_func  TYPE td_function_name.
  DATA d_type  TYPE td_comptype.

  TRY.
    d_type = component-&gt;get_type( ).
    CASE d_type.
      WHEN supportedtypes-group.
        d_group = component-&gt;get_name( ).
        result = get_group_signature( d_group ).
      WHEN supportedtypes-function.
        d_func = component-&gt;get_name( ).
        result = get_function_signature( d_func ).
      WHEN OTHERS.
        mac_raise_type_not_supported me-&gt;class_name d_type.
    ENDCASE.

    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~CREATE_NEW_RAW">
    <SOURCE>`
  DATA o_group    TYPE to_group.
  DATA o_function TYPE to_function.
  DATA o_raw_func TYPE to_raw_function.

  CASE type.
    WHEN supportedtypes-group.
      CREATE OBJECT object.
      CREATE OBJECT o_group.
      object-&gt;raw = o_group.
    WHEN supportedtypes-function.
      CREATE OBJECT o_raw_func.
      object = o_raw_func.
      CREATE OBJECT o_function.
      object-&gt;raw = o_function.
    WHEN OTHERS.
      CLEAR object.
      mac_raise_type_not_supported me-&gt;class_name type.
  ENDCASE.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~DELETE_FROM_SAP">
    <SOURCE>`
  DATA pool   TYPE rs38l-area.
  DATA d_func TYPE rs38l-name.
  DATA type   TYPE td_comptype.
  DATA name   TYPE td_compname.

  TRY.
    type = component-&gt;get_type( ).
    CASE type.
      WHEN supportedtypes-function.
        d_func = name = component-&gt;get_name( ).
        CALL FUNCTION &apos;RS_FUNCTION_DELETE&apos;
          EXPORTING
            funcname                 = d_func
            suppress_popups          = abap_true
*            SUPPRESS_CHECKS          = &apos; &apos;
*            SUPPRESS_DELE_ENHA       = &apos; &apos;
*            TRREQUEST                =
          EXCEPTIONS
            cancelled                = 1
            function_released        = 2
            OTHERS                   = 3.
        IF sy-subrc &lt;&gt; 0.
          mac_add_mf_and_raise &apos;RS_FUNCTION_DELETE&apos; sy-subrc.
        ENDIF.
      WHEN supportedtypes-group.
        pool = name = component-&gt;get_name( ).
        CALL FUNCTION &apos;FUNCTION_POOL_DELETE&apos;
          EXPORTING
            pool              = pool
            skip_progress_ind = &apos;X&apos;
          EXCEPTIONS
            functions_exists  = 1
            not_found         = 0
            OTHERS            = 3.
        IF sy-subrc &lt;&gt; 0.
          mac_add_mf_and_raise &apos;FUNCTION_POOL_DELETE&apos; sy-subrc.
        ENDIF.
      WHEN OTHERS.
        mac_raise_type_not_supported me-&gt;class_name type.
    ENDCASE.

    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.

  result = abap_true.
* Issue 137 =&gt; Remove from Working Area
  zaplink_tools=&gt;remove_comp_from_working_area( type = type
                                                name = name ).</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~DO_EXISTS">
    <SOURCE>`
  DATA d_group    TYPE td_functiongroup_name.
  DATA d_function TYPE TD_FUNCTION_NAME.
  DATA type       TYPE td_comptype.

  exists = me-&gt;exists-not_exists.

  TRY.
    type = component-&gt;get_type( ).
    CASE type.
      WHEN supportedtypes-group.
        d_group = component-&gt;get_name( ).
        CALL FUNCTION &apos;RS_FUNCTION_POOL_EXISTS&apos;
          EXPORTING
            function_pool   = d_group
          EXCEPTIONS
            pool_not_exists = 1
            OTHERS          = 2.
        IF sy-subrc = 0.    exists = me-&gt;exists-exists.   ENDIF.
      WHEN supportedtypes-function.
        d_function = component-&gt;get_name( ).
        CALL FUNCTION &apos;FUNCTION_EXISTS&apos;
          EXPORTING
            funcname                 = d_function
*         IMPORTING
*           GROUP                    =
*           INCLUDE                  =
*           NAMESPACE                =
*           STR_AREA                 =
          EXCEPTIONS
            FUNCTION_NOT_EXIST       = 1
            OTHERS                   = 2.
        IF sy-subrc = 0.    exists = me-&gt;exists-exists.   ENDIF.
      WHEN OTHERS.
        mac_raise_type_not_supported me-&gt;class_name type.
    ENDCASE.

    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~IS_SUPPORTED_VERSION">
    <SOURCE>`
  result = abap_false.
  if version = _ver.
    result = abap_true.
  endif.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~READ_FROM_SAP">
    <SOURCE>`
  DATA o_group    TYPE to_group.
  DATA o_function TYPE to_function.
  DATA s_fmd_fugr TYPE ts_fmd_fugr.
  DATA s_fmd_func TYPE ts_fmd_func.
  DATA d_name     TYPE td_compname.
  DATA type       TYPE td_comptype.
  DATA d_mainprog TYPE td_progname.
  DATA d_soft_comp TYPE tdevc-dlvunit.
  DATA t_functions TYPE tt_rs38l_incl.
*  DATA s_func LIKE LINE OF s_fmd_fugr-functions.
*  DATA t_doc TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
*  DATA t_src TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
*  DATA t_tmp_doc TYPE tt_docs.
  DATA d_doc TYPE doku_obj.
*  DATA s_doc_param TYPE zaplink_fugr_data=&gt;ts_doc_param.
*    BEGIN OF s_doc_param,
*      func   TYPE rs38l_fnam,
*      param TYPE rs38l_par_,
*    END OF s_doc_param.
  FIELD-SYMBOLS:
    &lt;f&gt; LIKE LINE OF t_functions.

  TRY.
    type = component-&gt;get_type( ).
    CREATE OBJECT object.
    object-&gt;set_component( component ).
    CASE type.
      WHEN supportedtypes-function.
        s_fmd_func-header-name = object-&gt;name.
        s_fmd_func = read_function( s_fmd_func-header-name ).
        s_fmd_func-code_signature = calc_function_signature( s_fmd_func ).
        CREATE OBJECT o_function.
        o_function-&gt;from_data( s_fmd_func ).
        CLEAR o_function-&gt;a0_maindata-name.
        object-&gt;raw = o_function.
      WHEN supportedtypes-group.
        s_fmd_fugr-header-area = d_name = object-&gt;name.
        CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
          EXPORTING
            function_pool           = s_fmd_fugr-header-area
          TABLES
            functab                 = t_functions
          EXCEPTIONS
            function_pool_not_found = 1
            OTHERS                  = 2.
        IF sy-subrc &lt;&gt; 0.
          mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; sy-subrc.
        ENDIF.

        d_doc = d_mainprog = get_mainprogram( s_fmd_fugr-header-area ).
        s_fmd_fugr-docs = zaplink_documentation=&gt;get( ids = zaplink_fugr_data=&gt;r_doc_ids-group
                                                  object = d_doc  ).

        SELECT * INTO TABLE s_fmd_fugr-texts FROM tlibt WHERE area = s_fmd_fugr-header-area.
* Issue 95
*        SELECT * INTO TABLE s_fmd_fugr-function_texts FROM tftit FOR ALL ENTRIES IN t_functions WHERE funcname = t_functions-funcname.
*        SELECT * INTO TABLE s_fmd_fugr-param_texts FROM funct FOR ALL ENTRIES IN t_functions WHERE funcname = t_functions-funcname.
        LOOP AT t_functions ASSIGNING &lt;f&gt;.
          s_fmd_func = read_function( &lt;f&gt;-funcname ).   clear s_fmd_func-header-str_area.
          s_fmd_func-code_signature = calc_function_signature( s_fmd_func ).
          INSERT s_fmd_func INTO TABLE s_fmd_fugr-functions.
        ENDLOOP.

        SELECT SINGLE dlvunit INTO d_soft_comp
          FROM v_tralan
          WHERE pgmid = supportedkinds-group
            AND object = supportedtypes-group
            AND obj_name = s_fmd_fugr-header-area.

        s_fmd_fugr-includes = get_all_includes( s_fmd_fugr-header-area ).

*          s_fmd_fugr-includes = remove_unwanted_includes( includes = s_fmd_fugr-includes
*                                                        functions = t_functions
*                                                        soft_comp = d_soft_comp ).

* Texts Pool
        s_fmd_fugr-textspool = get_prog_textpool( d_mainprog ).

* Dynpro
        s_fmd_fugr-dynpros = get_dynpros( d_mainprog ).

* Menu Painter
        s_fmd_fugr-menupainter = get_menus( d_mainprog ).
** Documentation
**      CONCATENATE _name &apos;*&apos; INTO _obj. &quot; Issue:7
*          s_obj-prog = _name.
*          s_obj-wildcard = &apos;*&apos;.
*          _obj = s_obj.
**Issue:7
*          o_group-&gt;documentation = zaplink_documentation=&gt;get( ids = r_doc_id
*                                                          object = _obj ).
        CREATE OBJECT o_group.
        o_group-&gt;from_data( s_fmd_fugr ).
        o_group-&gt;_code_signature = get_group_signature( o_group-&gt;a0_maindata-area ).
        CLEAR o_group-&gt;a0_maindata-area.
        object-&gt;raw = o_group.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me-&gt;class_name type.
    ENDCASE.
    object-&gt;update_connector_data( me ).                    &quot; Issue 66
    mac_def_catch ZCX_ZL_CONNECTOR.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~WRITE_TO_SAP">
    <SOURCE>`
  DATA o_group      TYPE to_group.
  DATA o_function   TYPE to_function.
  DATA s_fmd_fugr   TYPE ts_fmd_fugr.
  DATA s_fmd_func   TYPE ts_fmd_func.
  DATA _comp        TYPE to_component.
  DATA d_pname      TYPE tfdir-pname.
  DATA d_group      TYPE rs38l-area.
  DATA _name        TYPE td_compname.
  DATA d_mainprog   TYPE td_progname.
  DATA t_functions  TYPE tt_rs38l_incl.
  DATA d_msg        TYPE string.
  DATA d_answer     TYPE c.
  DATA t_doc        TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
  DATA t_src        TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
  DATA t_params     TYPE STANDARD TABLE OF spar WITH DEFAULT KEY.
  DATA t_source     TYPE tt_abaprawsource.
  DATA s_param      LIKE LINE OF t_params.
  DATA o_source     TYPE REF TO cl_wb_source.
  DATA t_key        TYPE  trkey.
  DATA source_name  TYPE  trdir-name.
  FIELD-SYMBOLS:
    &lt;i&gt;  LIKE LINE OF s_fmd_fugr-includes,
    &lt;fi&gt; LIKE LINE OF t_functions,
    &lt;f&gt;  LIKE LINE OF s_fmd_fugr-functions.

  TRY.
      CREATE OBJECT components.
      CASE object-&gt;type.
        WHEN supportedtypes-function.
          o_function ?= object-&gt;raw.
          o_function-&gt;a0_maindata-name = object-&gt;name.
          s_fmd_func = o_function-&gt;to_data( ).

          del_function( s_fmd_func ).
          write_function( s_fmd_func ).
          CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
            EXPORTING
              function_pool           = s_fmd_func-header-str_area
            TABLES
              functab                 = t_functions
            EXCEPTIONS
              function_pool_not_found = 1
              OTHERS                  = 2.
          IF sy-subrc &lt;&gt; 0.
            ROLLBACK WORK.
            mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; sy-subrc.
          ENDIF.
          READ TABLE t_functions ASSIGNING &lt;fi&gt; WITH KEY funcname = s_fmd_func-header-name.
          IF sy-subrc &lt;&gt; 0. mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; 2. ENDIF.
*          set_prog_rawsource( program = &lt;fi&gt;-include
*                                  raw = s_fmd_func-source ).

        WHEN supportedtypes-group.
          o_group ?= object-&gt;raw.
          o_group-&gt;a0_maindata-area = object-&gt;name.
          s_fmd_fugr = o_group-&gt;to_data( ).
          d_mainprog = get_mainprogram( s_fmd_fugr-header-area ).

          CALL FUNCTION &apos;RS_FUNCTION_POOL_DELETE&apos;
            EXPORTING
              area                         = s_fmd_fugr-header-area
*             CORRNUM                      = &apos; &apos;
*             TEXT                         = &apos; &apos;
*             UNAME                        = &apos; &apos;
*             WITH_KORR                    = &apos;X&apos;
*             WB_FB_MANAGER                =
              suppress_popups              = abap_true
              skip_progress_ind            = abap_true
*           IMPORTING
*             E_CORRNUM                    =
            EXCEPTIONS
              canceled_in_corr             = 1
              enqueue_system_failure       = 2
              function_exist               = 3
              not_executed                 = 4
              no_modify_permission         = 5
              no_show_permission           = 6
              permission_failure           = 7
              pool_not_exist               = 0
              cancelled                    = 9
              OTHERS                       = 10.
          IF sy-subrc &lt;&gt; 0.
            mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_DELETE&apos; sy-subrc.
          ENDIF.

* FUNCTIONS
          IF sy-batch = abap_false.   &quot;only delete in foreground
            LOOP AT s_fmd_fugr-functions ASSIGNING &lt;f&gt;.
              del_function( &lt;f&gt; ).
            ENDLOOP.
          ENDIF.

          CALL FUNCTION &apos;RS_FUNCTION_POOL_INSERT&apos;
            EXPORTING
              function_pool                 = s_fmd_fugr-header-area
              short_text                    = space
*             RESPONSIBLE                   = SY-UNAME
*             NAMESPACE                     = &apos; &apos;
*             DEVCLASS                      =
*             CORRNUM                       =
*             SUPPRESS_LANGUAGE_CHECK       = &apos;X&apos;
*             AUTHORITY_CHECK               = &apos;X&apos;
*             SUPPRESS_CORR_CHECK           = &apos;X&apos;
*             UNICODE_CHECKS                = &apos;X&apos;
*           IMPORTING
*             CORRNUM                       =
            EXCEPTIONS
              name_already_exists           = 1
              name_not_correct              = 2
              function_already_exists       = 3
              invalid_function_pool         = 4
              invalid_name                  = 5
              too_many_functions            = 6
              no_modify_permission          = 7
              no_show_permission            = 8
              enqueue_system_failure        = 9
              canceled_in_corr              = 10
              undefined_error               = 11
              OTHERS                        = 12.
          IF sy-subrc &lt;&gt; 0.
            ROLLBACK WORK.
            mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_INSERT&apos; sy-subrc.
          ENDIF.

* Text Pool
          set_prog_textpool( program = d_mainprog
                            textpool = s_fmd_fugr-textspool ).
* Dynpro
          set_dynpros( program = d_mainprog
                       dynpros = s_fmd_fugr-dynpros ).

* Menu Painter
          set_menus( program = d_mainprog
                       menus = s_fmd_fugr-menupainter ).

*Texts
          DELETE FROM tlibt WHERE area = s_fmd_fugr-header-area.
          MODIFY tlibt FROM TABLE s_fmd_fugr-texts.

*          MODIFY tftit FROM TABLE s_fmd_fugr-function_texts.     &quot; Issue 100
*          MODIFY funct FROM TABLE s_fmd_fugr-param_texts.        &quot; Issue 100

** Documentation
*          zaplink_documentation=&gt;set( t_docs = o_group-&gt;documentation ).

* INCLUDES
*ISSUE 125
          t_key-obj_type = supportedtypes-group.
          t_key-obj_name = s_fmd_fugr-header-area.
          t_key-sub_type = &apos;REPS&apos;.
          t_key-sub_name = d_mainprog.
          CREATE OBJECT o_source
             EXPORTING
               transport_key = t_key
               source_name = d_mainprog
*              modification_mode =
*              abap_editor =
*              method_key =
              .
          CALL METHOD o_source-&gt;read_source
*            EXPORTING
*              status                        = SPACE
*              toggle_enh_status             = SPACE
*              source_name                   = space
*              initialize_edit_control       = &apos; &apos;
*              load_from_temp_storage        = &apos;X&apos;
*              load_from_temp_storage_uncond = SPACE
*              with_conversion               = &apos;X&apos;
*              mode                          =
*              with_enhancements             = &apos;X&apos;
*              insert_impl_enh_points        = &apos; &apos;
*              p_current_enhname             =
             IMPORTING
               source_tab                    = t_source
*            CHANGING
*              mod_instance                  =
             EXCEPTIONS
               cancelled                     = 1
               enhancement_locked            = 2
               not_found                     = 3
               read_protected                = 4
               OTHERS                        = 5.
          IF sy-subrc &lt;&gt; 0.
            mac_add_obj_meth_and_raise o_source &apos;READ_SOURCE&apos; sy-subrc.
          ENDIF.
*ISSUE 125 - END
* Issue 97 : Includes not handled
          LOOP AT s_fmd_fugr-includes ASSIGNING &lt;i&gt;.
            write_include( EXPORTING area = s_fmd_fugr-header-area &quot; ISSUE 125
                              mainprogram = d_mainprog
                                  include = &lt;i&gt;
                          CHANGING source = t_source ).
          ENDLOOP.
* Issue 97 : End
          o_source-&gt;set_source_tab( t_source ).             &quot; ISSUE 125

          LOOP AT s_fmd_fugr-functions ASSIGNING &lt;f&gt;.
            write_function( &lt;f&gt; ).
          ENDLOOP.
* Issue 137
          Commit work.      &quot; Otherwise Pool conent is empty because inlcude UXX is not up to date

          CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
            EXPORTING
              function_pool           = s_fmd_fugr-header-area
            TABLES
              functab                 = t_functions
            EXCEPTIONS
              function_pool_not_found = 1
              OTHERS                  = 2.
          IF sy-subrc &lt;&gt; 0.
            ROLLBACK WORK.
            mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; sy-subrc.
          ENDIF.

          LOOP AT s_fmd_fugr-functions ASSIGNING &lt;f&gt;.
            READ TABLE t_functions ASSIGNING &lt;fi&gt;
                 WITH KEY funcname = &lt;f&gt;-header-name.
            IF sy-subrc &lt;&gt; 0.
              ROLLBACK WORK.
*              mac_add_mf_and_raise &apos;RS_FUNCTIONMODULE_INSERT&apos; 12.    &quot; CF write_function
              mac_add_mf_and_raise &apos;RPY_FUNCTIONMODULE_INSERT&apos; 11.    &quot; Issue 137
            ENDIF.
*            set_prog_rawsource( program = &lt;fi&gt;-include
*                                    raw = &lt;f&gt;-source ).
          ENDLOOP.

        WHEN OTHERS.
          mac_raise_type_not_supported me-&gt;class_name object-&gt;type.
      ENDCASE.
      check_component_list( EXPORTING     object = object
                             CHANGING components = components ). &quot; Issue 92

    CATCH ZCX_ZL_CONNECTOR INTO o_mycx.
      ROLLBACK WORK.
      RAISE EXCEPTION o_mycx.
    CATCH ZCX_ZAPLINK INTO o_cx.
      ROLLBACK WORK.
      mac_cascade_raise o_mycx o_cx.
  ENDTRY.</SOURCE>
   </ITEM>
  </REDEFINITIONS>
  <TEXTSPOOL>
   <ITEM ID="I" KEY="D00">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Confirm module function deletion" LENGTH="50 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="HNO">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Function is not deleted and process to next existing function. Function group will be created without this function." LENGTH="132 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="HYE">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Function is deleted. Function group will be created with this function." LENGTH="132 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="NO_">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="No" LENGTH="15 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="YES">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Yes" LENGTH="15 "/>
    </TEXTS>
   </ITEM>
  </TEXTSPOOL>
  <TYPEGROUPS>
   <ITEM TYPEGROUP="ABAP" EXPLICIT="X"/>
  </TYPEGROUPS>
  <TYPES>
   <ITEM CMPNAME="TD_FUNCTIONGROUP_NAME" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="1" TYPE="TLIBG-AREA">
    <TEXTS>
     <ITEM LANG="E" TEXT="Function group, to which the function module belongs"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TD_FUNCTION_NAME" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="RS38L-NAME">
    <TEXTS>
     <ITEM LANG="E" TEXT="Name of Function Module"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TD_INCLUDENAME" EXPOSURE="1" STATE="1" EDITORDER="4 " TYPTYPE="1" TYPE="ZAPLINK_FUGR_DATA=&gt;TD_INCLUDENAME"/>
   <ITEM CMPNAME="TO_FUNCTION" EXPOSURE="1" STATE="1" EDITORDER="2 " TYPTYPE="3" TYPE="ZAPLINK_FUNC_DATA">
    <TEXTS>
     <ITEM LANG="E" TEXT="Commun Data for Class &amp; Interface"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TO_GROUP" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="3" TYPE="ZAPLINK_FUGR_DATA">
    <TEXTS>
     <ITEM LANG="E" TEXT="Data for Function group"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TO_RAW_FUNCTION" STATE="1" EDITORDER="3 " TYPTYPE="1" TYPE="ZAPLINK_FUGR_DATA=&gt;TO_FUNCTION"/>
   <ITEM CMPNAME="TS_FMD_FUGR" EXPOSURE="1" STATE="1" EDITORDER="5 " TYPTYPE="1" TYPE="ZAPLINK_FUGR_DATA=&gt;TS_FM_DATA"/>
   <ITEM CMPNAME="TS_FMD_FUNC" EXPOSURE="1" STATE="1" EDITORDER="6 " TYPTYPE="1" TYPE="ZAPLINK_FUNC_DATA=&gt;TS_FM_DATA"/>
   <ITEM CMPNAME="TS_INCLUDE" EXPOSURE="1" STATE="1" EDITORDER="7 " TYPTYPE="1" TYPE="ZAPLINK_FUGR_DATA=&gt;TS_RAWINCLUDE"/>
   <ITEM CMPNAME="TS_PROG_ATTR" STATE="1" EDITORDER="1 " TYPTYPE="4">
    BEGIN OF ts_prog_attr.
  INCLUDE TYPE ts_base_attributs AS base.
  TYPES:
    END OF ts_prog_attr
`
    <TEXTS>
     <ITEM LANG="E" TEXT="Program Attributs"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TS_SOURCE" EXPOSURE="2" STATE="1" EDITORDER="8 " TYPTYPE="1" TYPE="STRING">
    <TEXTS>
     <ITEM LANG="E" TEXT="ABAP Source code"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TS_TEXT" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4">begin of ts_text,
      langu   type SPRAS,
      ENTRY	  type TEXTPOOLTX,
      LENGTH  type TEXTPOOLLN,
    end of ts_text
`</ITEM>
   <ITEM CMPNAME="TS_TEXTPOOL" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="4">begin of ts_textpool,
      ID    type  TEXTPOOLID,
      KEY	  type  TEXTPOOLKY,
      texts type  tt_texts,
    end of ts_textpool
`</ITEM>
   <ITEM CMPNAME="TT_INCLUDES" EXPOSURE="1" STATE="1" EDITORDER="3 " TYPTYPE="1" TYPE="ZAPLINK_FUGR_DATA=&gt;TT_RAWINCLUDES"/>
   <ITEM CMPNAME="TT_RS38L_INCL" STATE="1" EDITORDER="2 " TYPTYPE="4">
    tt_rs38l_incl TYPE STANDARD TABLE OF rs38l_incl WITH DEFAULT KEY
`
    <TEXTS>
     <ITEM LANG="E" TEXT="standard table of rs38l_incl"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TT_TEXTPOOLS" EXPOSURE="2" STATE="1" EDITORDER="7 " TYPTYPE="4">
    TT_TEXTPOOLs type SORTED TABLE OF ts_textpool WITH UNIQUE key ID KEY
`
    <TEXTS>
     <ITEM LANG="E" TEXT="Table of textppool"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TT_TEXTS" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4">tt_texts type SORTED TABLE OF ts_text WITH UNIQUE KEY langu
`</ITEM>
   <ITEM CMPNAME="T_RAW" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="1" TYPE="RSWSOURCET">
    <TEXTS>
     <ITEM LANG="E" TEXT="ABAP Source"/>
    </TEXTS>
   </ITEM>
  </TYPES>
 </RAW>
</ZL_OBJECT>
